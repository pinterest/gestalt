// @flow strict
const StyleDictionary = require('style-dictionary');

// FORMATTING HELPERS

// $FlowFixMe[missing-local-annot]
function mapDarkTheme(dictionary) {
  return dictionary.allTokens.map((token) => {
    const { darkValue } = token;
    if (darkValue) {
      return { ...token, value: token.darkValue };
    }
    return token;
  });
}

function formatDarkTheme(format /*: string */) {
  // $FlowFixMe[missing-local-annot]
  return (args) => {
    const dictionary = { ...args.dictionary };
    // Override each token's `value` with `darkValue`
    dictionary.allTokens = mapDarkTheme(dictionary);
    // Use the built-in format but with our customized dictionary object
    // so it will output the darkValue instead of the value
    return StyleDictionary.format[format]({
      ...args,
      dictionary,
    });
  };
}

// $FlowFixMe[missing-local-annot]
function formatFlowTypes(dictionaryTokens) {
  return `// @flow strict\n/* File is autogenerated */\n\ndeclare module.exports: {|\n${dictionaryTokens
    .map((token) => `  +"${token.name}": ${JSON.stringify(token.value)}`)
    .join(',\n')}\n|}`;
}

// REGISTER FILE HEADERS

const { fileHeader } = StyleDictionary.formatHelpers;

StyleDictionary.registerFileHeader({
  name: 'fileHeader',
  // defaultMessage contains the 2 lines that appear in the default file header
  fileHeader: (defaultMessage) => ['File is autogenerated', ...defaultMessage],
});

StyleDictionary.registerFileHeader({
  name: 'flowFileHeader',
  // defaultMessage contains the 2 lines that appear in the default file header
  fileHeader: (defaultMessage) => ['@flow strict \n// File is autogenerated', ...defaultMessage],
});

StyleDictionary.registerFileHeader({
  name: 'androidFileHeader',
  fileHeader: (defaultMessage) => ['File is autogenerated', ...defaultMessage],
});

// REGISTER FORMATS

const regex = /(\{|\})/gi;

StyleDictionary.registerFormat({
  name: 'commonJS/flow',
  formatter: ({ dictionary, file }) => {
    const tokenArray = dictionary.allTokens.map((token) =>
      JSON.stringify({
        name: token.path.join('-'),
        value: token.value,
        originalValue: token.original.value?.replace(regex, ''),
        darkValue: token.darkValue,
        originalDarkValue: token.original.darkValue?.replace(regex, ''),
        comment: token.comment,
        category: token.attributes.category,
      }),
    );
    return `${fileHeader({ file, commentStyle: 'short' })} module.exports = [${tokenArray}]`;
  },
});

StyleDictionary.registerFormat({
  name: 'javascript/es6/flow',
  // https://amzn.github.io/style-dictionary/#/formats?id=javascriptes6
  formatter: ({ dictionary }) =>
    `// @flow strict\n\n${StyleDictionary.format['javascript/es6']({
      dictionary,
    })}`,
});

StyleDictionary.registerFormat({
  name: 'darkThemeFormat-css/variables',
  formatter: formatDarkTheme('css/variables'),
});

StyleDictionary.registerFormat({
  name: 'darkThemeFormat-android/resources',
  formatter: formatDarkTheme('android/resources'),
});

StyleDictionary.registerFormat({
  name: 'darkThemeFormat-json/flat',
  formatter: formatDarkTheme('json/flat'),
});

function jsonFlatFlow() {
  // $FlowFixMe[missing-local-annot]
  return ({ dictionary }) => formatFlowTypes(dictionary.allTokens);
}
function cssDarkJsonFlatFlow() {
  // $FlowFixMe[missing-local-annot]
  return ({ dictionary }) => formatFlowTypes(mapDarkTheme(dictionary));
}

StyleDictionary.registerFormat({
  name: 'json/flat/flow',
  formatter: jsonFlatFlow(),
});

StyleDictionary.registerFormat({
  name: 'darkThemeFormat-json/flat/flow',
  formatter: cssDarkJsonFlatFlow(),
});

StyleDictionary.registerFormat({
  name: `constantLibrary-javascript/es6/flow`,
  formatter({ dictionary }) {
    return `// @flow strict\n\n/* File is autogenerated */\n\n${dictionary.allTokens
      .map((token) => {
        let value = JSON.stringify(token.value);
        // the `dictionary` object now has `usesReference()` and
        // `getReferences()` methods. `usesReference()` will return true if
        // the value has a reference in it. `getReferences()` will return
        // an array of references to the whole tokens so that you can access their
        // names or any other attributes.
        if (dictionary.usesReference(token.original.value)) {
          // Note: make sure to use `token.original.value` because
          // `token.value` is already resolved at this point.
          const refs = dictionary.getReferences(token.original.value);
          refs.forEach((ref) => {
            value = value.replace(ref.value, () => `${ref.name}`);
          });
        }
        return `export const TOKEN_${token.path
          .join('_')
          .toUpperCase()
          .replace('-', '_')} = 'var(--${token.path.join('-')})';`;
      })
      .join(`\n`)}`;
  },
});

StyleDictionary.registerFormat({
  name: `constantLibrary-commonJS/flow`,
  formatter({ dictionary, file }) {
    const tokens = dictionary.allTokens
      .map((token) => {
        let value = JSON.stringify(token.value);
        // the `dictionary` object now has `usesReference()` and
        // `getReferences()` methods. `usesReference()` will return true if
        // the value has a reference in it. `getReferences()` will return
        // an array of references to the whole tokens so that you can access their
        // names or any other attributes.
        if (dictionary.usesReference(token.original.value)) {
          // Note: make sure to use `token.original.value` because
          // `token.value` is already resolved at this point.
          const refs = dictionary.getReferences(token.original.value);
          refs.forEach((ref) => {
            value = value.replace(ref.value, () => `${ref.name}`);
          });
        }
        return `  TOKEN_${token.path
          .join('_')
          .toUpperCase()
          .replace('-', '_')}: 'var(--${token.path.join('-')})',`;
      })
      .join(`\n`);

    return `${fileHeader({
      file,
      commentStyle: 'short',
    })}module.exports = Object.freeze({\n${tokens.slice(0, -1)}\n})`;
  },
});

// REGISTER FILTERS

// Filters only tokens with dark theme values
StyleDictionary.registerFilter({
  name: 'darkThemeFilter',
  matcher(token) {
    return (
      token.darkValue &&
      (token.attributes.category === 'color' || token.attributes.category === 'elevation')
    );
  },
});

// Filters only tokens with data-visualization
StyleDictionary.registerFilter({
  name: 'dataVisualizationFilter',
  matcher(token) {
    return token.attributes.category === 'color' && token.attributes.type === 'data-visualization';
  },
});

// REGISTER TRANSFORMS

StyleDictionary.registerTransform({
  name: 'size/pxToDpOrSp',
  type: 'value',
  matcher(prop) {
    return prop.value.match(/^-?[\d.]+px$/);
  },
  transformer(prop) {
    return prop.name.includes('font')
      ? prop.value.replace(/px$/, 'sp')
      : prop.value.replace(/px$/, 'dp');
  },
});

// REGISTER TRANSFORM GROUPS

StyleDictionary.registerTransformGroup({
  name: 'androidTransformGroup',
  transforms: ['attribute/cti', 'name/cti/snake', 'color/hex8android', 'size/pxToDpOrSp'],
});

StyleDictionary.extend('config.json').buildAllPlatforms();
